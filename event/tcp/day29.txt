poll实现IO多路复用

p = select.poll()
  功能：创建poll对象
  返回值：poll对象

p.register(fd,event)
  功能：注册要关注的IO事件
  参数：fd  要关注的IO对象
      event 选择要关注的事件
         常用事件类型：POLLIN 读IO事件 rlist
	               POLLOUT 写IO事件 wlist
		       POLLERR 出错IO xlist
		       POLLHUP 连接断开事件
   e.g. p.register(sockfd,POLLIN | POLLERR)
   
p.unregister(fd)
  功能：取消对IO的关注
  参数：IO对象或者是文件描述符

events = p.poll()
  功能：阻塞等待监控的IO事件发生
  返回值：events是一个列表 格式如下；
        [(fileno,event),(),()...]
        其中每个元组为一个就绪的IO事件
        元组中有该IO的fileno和就绪的事件类型

*需要字典配合通过fileno查找对应的IO事件对象
{fileno:io_obj}   e.g. {sockfd.fileno():sockfd}

poll_server 步骤
  1.创建套接字
  2.将套接字设置为关注
  3.创建查找字典，并维护
  4.循环监控IO发生
  5.处理发生的IO事件

epoll方法实现IO多路复用

使用方法：基本与poll方法相同
  *生成对象改为epoll()方法
  *事件类型改为EPOLL类型

epoll特点：
  *epoll效率比select和poll要高
  *epoll的IO监控数量比select要多
  *epoll的触发方式更多（边缘触发）

发送更丰富的数据结构

struct 模块 结构化数据
  原理：将数据转换为bytes格式，并且可以将bytes格式数据转换回来

Struct(fmt)
  功能：生产struct对象
  参数：fmt定制的数据结构组成
      e.g. ：
        要发的数据：1 b'zhang' 1.75
	组织的类型格式：Struct('i5sf')

       python类型    fmt
          int         i
	  float       f
	  bytes       ns  (n代表有几个字符)
返回：struct对象

st.pack(v1,v2,v3...)
  功能：将数据按照指定格式打包转换为bytes
  参数：要发送的数据
  返回值：打包后的bytes字节串
    e.g.  st.pack(1,b'zhang',1.75)

st.unpack(bytes_data)
  功能：将bytes字串解析为指定格式数据
  参数：要解析的bytes字串
  返回值：元组，为解析后的内容

*struct模块可以直接调用pack() unpack()
   此时两个函数第一个参数为fmt
   e.g.
    struct.pack('i5sf',1,b'zhang',1.75)

本地套接字
  功能：本地两程序之间发送数据信息

  创建流程：
    1、创建本地套接字
      sockfd = socket(AF_UNIX,SOCK_STREAM)
    2、绑定本地套接字文件
      sockfd.bind(path)
    3、监听
      listen()
    4、消息收发
      send  recv

多任务编程
  意义：充分利用计算机资源提高程序的运行效率
  定义：通过一定的编程手段，在一个程序运行中可以同时利用计算机执行多个任务，
        以此提高程序运行效率
实现方案：多进程  多线程
  并发：同时处理多个任务。内核在任务间不断的切换达到好像多个任务均被执行的效果
        实际每个时刻只有一个任务占有内核
  并行：多个任务利用计算机多核资源在同时执行，此时多个任务间为并行关系

进程(Process)
  定义：程序在计算机中的一次运行过程
    程序：是一个可执行的文件，是静态的占有磁盘空间
    进程：进程是一个动态的过程，占有计算机资源，有一定的生命周期
  进程的诞生
    1、用户空间通过调用程序接口或者命令发起进程创建请求
    2、操作系统接收用户请求，开始创建进程
    3、操作系统分配计算机资源，确定进程状态，开辟空间等
    4、操作系统将创建的进程提供给用户使用
  一些概念
    cpu时间片：如果一个进程占有cpu内核则称这个进程在cpu时间片上
    PCB（进程控制块）：在内存中开辟的一块空间存放进程的基本信息
    进程ID（PID）：系统为进程分配的ID号，每个进程不重复
         查看命令： ps -aux
    父子进程：系统中每一个进程都有唯一的父进程，可以有多个或0个子进程，
              这样形成父子进程关系
	 查看命令：pstree

  进程状态
    三态：
         就绪态：进程具备执行条件，等待系统分配cpu资源
	 运行态：进程占有cpu时间片正在运行
	 等待态：进程暂时阻塞不具备执行条件
    五态（增加新建态和终止态）
         新建态：创建一个新的进程，获取资源的过程
	 终止态：进程结束，释放资源的过程

	 查看命令:ps -aux --> STAT列
	          S  等待态
		  D  等待态
		  T  等待态
		  R  运行态（包含就绪态）
		  Z  僵尸
  进程优先级
    作用：决定进程的优先权限和占有资源的优先程度
    查看命令：top  动态查看进程优先级
    Linux 优先级范围 -20 ~19数字越小优先级越高
    指定优先级运行程序
    nice -9 python3 while.py   以9的优先级运行
    nice --9 python3 while.py  以-9的优先级运行
    
    <  有较高的优先级
    N  有较低的优先级
    +  前台进程
    s  会话组组长
    L  有链接子进程的

  进程的特征
    1、进程可以使用计算机的多核资源
    2、进程是计算机分配系统资源的最小单位
    3、进程之间运行互不影响，各自独立运行
    4、每个进程的空间独立，各占有自己的空间资源
  
  要求：
    1.什么是进程，进程和程序的区别
    2.进程的特征有哪些
    3.进程都有哪些状态，各种状态如何转换
  
  多进程编程
     import os
     pid = os.fork()
     功能：创建新的进程
     参数：无
     返回值：失败：返回一个负数
             成功：在原进程中返回新进程的PID号
	           在新进程中返回0

      注意：
        *子进程会复制父进程的全部代码段和内存空间
	*子进程从fork的下一句开始执行
	*if elif else 结构判断fork返回值的不同从而使父子进程执行不同的代码几乎是固定搭配
	*父子进程各自独立运行，运行顺序不一定
	*子进程有自己特有的内容 比如PID 进程控制块 命令集
     
      fork注意
        1、进入阻塞状态的进程一定会让出cpu时间片
        2、各个进程在自己空间内对数据的操作不影响其他进程
        3、父进程在执行fork之前开辟的空间子进程也会复制


作业：
  对进程中 要求 的理论问题总结
  整理网络编程知识点，回顾重点程序

1、进程(Process)
  定义：程序在计算机中的一次运行过程
    程序：是一个可执行的文件，是静态的占有磁盘空间
    进程：进程是一个动态的过程，占有计算机资源，有一定的生命周期

2、进程的特征
    1、进程可以使用计算机的多核资源
    2、进程是计算机分配系统资源的最小单位
    3、进程之间运行互不影响，各自独立运行
    4、每个进程的空间独立，各占有自己的空间资源

3、进程状态
    三态：
         就绪态：进程具备执行条件，等待系统分配cpu资源
	 运行态：进程占有cpu时间片正在运行
	 等待态：进程暂时阻塞不具备执行条件
    五态（增加新建态和终止态）
         新建态：创建一个新的进程，获取资源的过程
	 终止态：进程结束，释放资源的过程

  聊天室：类似qq群聊
    功能：每个人进入聊天室其他人会收到通知
          进入聊天室需要输入姓名，姓名不能和已有的重复
          xxx进入了聊天室
	  一人发言其他人都能收到
	  每个人退出也会给其他人通知
	  xxx退出了聊天室
	  xxx说：xxxxxxxx
	  管理员喊话：群里人都能收到（服务端发言）
	  管理员说：xxxxxxx