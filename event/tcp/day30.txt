fork注意
  1、进入阻塞状态的进程一定会让出cpu时间片
  2、各个进程在自己空间内对数据的操作不影响其他进程
  3、父进程在执行fork之前开辟的空间子进程也会复制

进程相关函数
  os.getpid() ：返回当前进程的pid
    功能：获取当前进程的pid
    返回值：返回当前进程的pid

  os.getppid()
    功能：获取父进程的pid
    返回值：返回父进程的pid

  os._exit(status)
    功能：退出进程     一般用于线程退出，子进程
    参数：整数  表示自定义的进程状态标志

  sys.exit([status])
    功能：退出进程     一般用于主线程退出
    参数：整数  表示退出状态 默认为0
          传入一个字符串，则退出时会打印该字串

  孤儿进程和僵尸进程

    孤儿进程：父进程先于子进程退出，此时子进程就会成为孤儿进程
      *孤儿进程会被系统进程收养，此时系统进程就会成为该进程新的父进程
    
    僵尸进程：子进程先于父进程退出，父进程没有处理子进程退出状态，
              此时子进程就会成为僵尸进程
      *僵尸进程虽然结束但是会存留部分PCB在内存，大量的僵尸进程会占用内存资源

    如何避免僵尸进程的产生
      *处理子进程退出状态
        pid,status = os.wait()
	功能：在父进程中阻塞等待子进程的退出
	返回值：pid    退出的子进程的PID
	        status 子进程的退出状态
         
       （升级版）
        pid,status = os.waitpid(pid,option)
	功能：在父进程中阻塞等待子进程退出
	参数：pid -1 表示等待任意子进程
	          >0 等待指定pid的子进程退出
	      option    0    表示阻塞等待
	             WNOHANG 表示非阻塞
	返回值：pid    退出的子进程的PID
	        status 子进程的退出状态

      *创建二级子进程
        1.父进程创建子进程等待子进程退出
	2.子进程再创建二级子进程然后退出
	3.二级子进程成为孤儿，和原来父进程各执行任务

群聊聊天室
确定需求   基本技术分析  整体设计  功能分析   代码实现   代码测试

功能：类似qq聊天
   1.进入聊天室需要输入姓名，姓名不能重复
   2.进入聊天室会向其他人发送通知
     ‘xxxx 进入聊天室’
   3.一个人发消息群里其他人都收的到(自己收不到)
     ‘xxx 说：xxxxxxx’
   4.某人退出聊天室其他人也会收到通知
     ‘xxx 退出了聊天室’
   5.管理员可以发送管理员消息，此时所有人都收到消息(服务端发出)
     ‘管理员说：xxxxxxx’
 
  确定技术模型
    消息发送：转发  先发给服务器再转发给其他人
    套接字选择：UDP套接字
    用户存储：字典{name:ip}
    收发关系处理：多进程分别处理发送接收

  整体封装
    1、封装  将每个功能封装为函数
    2、测试  实现一个功能测试一个功能
    3、编写流程  搭建网络连接 逐个功能实现 

  具体功能实现
    网络连接
      服务端：创建udp套接字，绑定地址
      客户端：创建套接字

    登录
      服务端：接收姓名
              判断姓名收否存在
	      根据判断结果返回相应信息
	      如果不允许登录则功能结束
	      如果允许登录将用户加入维护的数据结构
	      将用户登录提示信息发给其他人
      客户端：输入姓名
              将姓名发送给服务端
	      接收服务端确认信息
	      如果不允许则重新输入
	      如果允许则进入聊天室
	      创建新的进程，一个用于收消息，一个用于发消息

    发送消息

    退出
      服务端
        接收消息确定消息类型
	将用户从字典移除
	给其他人发送通知
	给退出的客户端发送退出标志
      客户端
        

    管理员喊话


作业：
  1.梳理聊天室代码思路
  2.整理fork创建进程的特征
  3.创建父子进程同时复制一个文件
    各复制文件的一半到新的文件中

   创建进程注意：
      *如果父进程创建对象后，创建子进程，子进程从父进程获取对象，
       此时父子进程在对象操作上会有一定的相互影响
      e.g. 套接字对象监听相同的端口，文件对象会使用同一个偏移量

      *如果父进程先创建子进程，则父子进程中各自产生的对象没有任何关系