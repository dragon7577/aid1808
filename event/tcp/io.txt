IO
阻塞IO
  默认形态
非阻塞IO
  sockfd.setblocking(bool) 默认True，调用时阻塞
  sockfd.settimeout(sec)
IO多路复用
  select
    re,ws,xs = select(rlist,wlist,xlist[,timeout])
  poll
    p = select.poll()
    p.register(fd,event)
        event:POLLIN
              POLLOUT
              POLLERR
              POLLHUP
    p.unregister(fd)
        events:[(fileno,event),(),(),...]
    poll_server:
      s = socket()
      s.setsockopt(SOL_SOCKET,SO_REUSEADDR,1)
      s.bind(addr)
      s.listen(n)
      p = poll()
      fdmap = {s.fileno():s}
      p.register(s,POLLIN|POLLERR)
      while True:
          events = p.poll()
          for fd,event in events:
              if fd == s.fileno():
                  c,addr = fdmap[fd].accept()
                  print("Connect from",addr)
                  p.register(c,POLLIN|POLLHUP)
                  fdmap[c.fileno()] = c
              elif event & POLLIN:
                  data = fdmap[fd].recv(1024)
                  if not data:
                      p.unregister(fd)
                      fdmap[fd].close()
                      del fdmap[fd]
                  else:
                      print("Receive:",data.decode())
                      fdmap[fd].send("收到了".encode())
    poll_client:---tcp_client           
  epoll
    生成对象改为epoll()
    事件类型改为EPOLL
       epoll效率比select和poll高
       IO监控数量比select多
       触发方式多（边缘触发）

struct 模块
  Struct(fmt)
  st.pack(v1,v2,v3...)
  st.unpack(bytes_data)
本地套接字
  sockfd = socket(AF_UNIX,SOCK_STREAM)
  sockfd.bind(path)
  listen()
  send recv



























