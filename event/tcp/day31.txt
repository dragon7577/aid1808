multiprocessing  模块创建进程
  1、将需要执行的进程事件封装为函数
  2、使用模块的Process类生成进程对象，并关联相应函数
  3、可以通过对象属性设置进程信息
  4、启动进程，此时会自动运行绑定的函数，作为一个进程来执行
  5、回收进程

Process()
  功能：创建进程对象
  参数：target  绑定的目标函数
        name    给进程起名字，默认为Process-1
        args    元组  给target目标函数按照位置传参
	kwargs  字典  给target目标函数按照键值传参

p.start()
  功能：启动进程 
  *target 绑定的函数开始执行，进程真正创建

p.join([timeout])
  功能：阻塞等待回收进程
  参数：timeout 超时时间

*使用multiprocessing创建进程，同样子进程复制父进程的全部空间代码段
 父子进程执行互不影响，各自有各自的运行空间，子进程只执行对应的函数部分
*如果不使用join回收子进程则子进程会成为僵尸进程
*multiprocessing中父进程往往只用来管理子进程的创建回收，具体事件由子进程完成

进程对象属性
p.name   进程名称
p.pid    进程PID号
p.daemon 
   默认为False 表示进程退出不会影响子进程的执行
   如果设置为True 此时主进程退出子进程也会退出
   *在start前设置，且一般不和join一起使用
p.is_alive() 查看进程是否在生命周期

自定义进程类
  1、继承Process类
  2、编写自己的__init__添加自己的属性
     重新加载父类的__init__方法
  3、重写run方法
  4、使用自己的类创建进程对象
  5、调用start()启动进程，此时会自动执行run方法
  6、调用join()回收进程

多进程的一些问题
  优点：可以使用计算机的多核同时运动型多个任务，提高了运行效率
  缺点：进程创建删除需要消耗的系统资源较多

进程池技术
  产生原因：如果有大量任务需要多进程完成，则可能要频繁的创建删除进程，此时给计算机带来的压力较大
  原理：创建一定量的进程作为进程池，用来处理事件。事件处理完毕后不销毁进程，而是继续等待处理其他
        的事件，直到所有待处理事件结束再统一销毁进程，增加进程的重复利用，降低资源消耗。

使用方法：
  1、创建进程池，放适当的进程
  2、将要做的事件放入进程池等待队列
  3、不断取事件使用进程池中进程执行，直到所有事件处理完毕
  4、关闭进程池，回收进程

from multiprocessing import Pool

Pool(processes)
  功能：创建进程池对象
  参数：指定进程池中进程的数据量，默认根据系统自动判定

pool.apply_async(func,args,kwds)
  功能：使用进程池中的进程执行相应函数
  参数：func  进程事件函数
        args  元组  给func按位置传参
        kwds  字典  给func按键值传参

pool.close()
  功能：关闭进程池，不能再添加新的事件

pool.join()
  功能：阻塞等待回收进程池进程

pool.map(func,iter)
  功能：将要做的事件加入进程池
  参数：func  事件函数
        iter  迭代函数
  返回值：函数的返回值列表

进程间通信  （IPC）
  原因：进程空间相对独立，资源无法互相获取，此时在不同进程间需要专门的方法进行通信

  进程间通信：管道  消息队列  共享内存  信号  信号量  套接字

  管道(Pipe)
    通信原理：在内存中开辟管道空间，生成管道操作对象，多个进程使用同一个管道对象
              进行读写即可实现通信
    from multiprocessing import Pipe

    fd1,fd2 = Pipe(duplex = True)
      功能：创建管道
      参数：默认表示双向管道
       	    如果设置为False 则为单向管道
      返回值：表示管道两端的读写对象
              如果是双向管道则两端都可以读写
      	      如果是单向管道则fd1只读 fd2只写
    fd.recv()
      功能：从管道读取内容
      返回值：读到的内容
      当管道为空则阻塞

    fd.send()
      功能：向管道写入内容
      参数：要写入的数据
      *可以写入python的数据类型
  
  消息队列
    队列：先进先出
    原理：在内存中建立队列模型，进程通过队列队形将消息存入队列，或者从队列取出消息
          完成进程间的通信
    from multiprocessing import Queue
    q = Queue(maxsize = 0)
      功能：创建队列对象
      参数：表示队列中最多存放多少个消息
      返回值：队列对象 
    q.put(data,[block,timeout])
      功能：向队列存入消息
      参数：data    要存入的内容 python数据
            block   默认队列满时会阻塞，设置为False则为非阻塞
	    timeout 超时检测
    q.get([block,timeout])
      功能：从队列获取消息
      参数：block   默认当队列为空时阻塞，设置为False则为非阻塞
            timeout 超时检测
    q.full()  判断队列是否为满
    q.empty() 判断队列是否为空
    q.qsize() 返回队列中消息的个数
    q.close() 关闭队列

作业：
  1、整理multiprocessing创建进程的方法，比较和fork的优劣
  2、网络项目 聊天室 tcp udp通信
  3、httpserver 复习 整理http协议
  4、复习mysql内容

multiprocessing
  Process 
          Process(target=*,name=*,args=(*,),kwargs={})
	    p.start()
	    p.join([timeout])
	    p.name
	    p.pid
	    p.daemon
	    p.is_alive()
  Pool
          Pool(processes)
	    pool.apply_async(func,args,kwds)
	    pool.close()
	    pool.join()
	    pool.map(func,iter)
  Pipe
          fd1,fd2 = Pipe(duplex = True)
	  fd.send()
	  fd.recv()
  Queue
          q = Queue(maxsize = 0)
	  q.put(data,[block,timeout])
	  q.get([block,timeout])
	  q.full()
	  q.empty()
	  q.qsize()
	  q.close()

fork
import os 
pid = os.fork()
os.getpid()
os.getppid()
os._exit(status)
sys.exit([status])
避免僵尸进程
一、  pid,status = os.wait()

      pid,status = os.waitpid(pid,option)      
             pid：-1   >0
          option: 0    WNOHANG 
二、  创建二级子进程
        1.父进程创建子进程等待子进程退出
	2.子进程再创建二级子进程然后退出
	3.二级子进程成为孤儿，和原来父进程各执行任务
